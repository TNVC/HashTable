# Тема: Исследование возможностей оптимизации ПО на примере хеш-таблицы
### Направление: "Введение в эмуляцию вычислительных систем, компиляторные технологии и промышленное программирование"
**Выполнил Буторин Даниил**
## Цель
Изучить различные реализации хеш-функций, изучить их дисперсию; исследовать реализацию инфроструктуры хеш-таблтцы на предмет возможных оптимизаций, внедрение найденных решений, вычисление коэффициента полезного прироста производительности ассемблерной оптимизации.
## В работе используются
Язык программирования C\C++; набор компиляторов GCC; инструмент callgrind утилиты valgrind; инструмент визуализации KCachegring.
## Экспериментальная установка
Ноутбук фирмы "Honor" на процессоре "AMD Ryzen 5 5500U with Radeon Graphics" с OS "GNU/Linux 22.04.1-Ubuntu x86_64".
## Теоретическая справка:
Хеш-функция — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку определенной длины(также называемую ключем). Возвращаемые хеш-функцией значения менее разнообразны, чем входные значения. Случай, при котором хеш-функция преобразует более чем одно значение входных данных в одинаковые ключи, называется "коллизией". Вероятность возникновения коллизий используется для оценки качества хеш-функций.

Ассоциативный массив — абстрактный тип данных, позволяющий хранить пары вида (ключ, значение). Реализация ассоциативного массива может быть представлена хеш-таблицей с разрешением коллизий путем цепочек(каждая ячейка - односвязанный список).

Заселенность хеш-таблицы - среднее количество элементов, приходящихся на каждую ячейку таблицы.

## Ход работы
### _Глава первая. Исследование дисперсии хеш-функций._
> Так как вычисляемая дисперсия распределения хеш-функций зависит от размеров хеш-таблицы,
> то выберем ее размеры оптимальным путем для текущей задачи: заселенность таблицы будет 10-15 элементов.

> Хеш-таблица будет представлена интерфейсом ассоциативного массива с типом (`String`, `String`).

Далее будет приведены разные реализации хеш-функции с их описанием и дисперсией в случае близкого к равномерному распределения(тогда дисперсия будет наименьшей).
Все реализации имеют следующую сигнатуру.
```clike=
typedef uint32_t Hash;
Hash GetHash(const char *value);
```
#### Хеш-функия №1: Эквивалентная константе.
```clike=
Hash GetHash(const char *value)
{
    return CONSTANT_VALUE;
}
```
Хеш-функия возвращает константу для каждого полученного значения.
Самая легкая реализация, но функция обладает крайней неэффективностью.
Неприменима.

<details>
<summary> Распределение хеш-функции  </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23ConstHash%23607.png?raw=true)

</details>

#### Хеш-функия №2: Длина значения.
```clike=
Hash GetHash(const char *value)
{
    return strlen(value);
}
```
Хеш-функия возвращает длину полученного значения. Очевидно, для задач с похожей длиной ключей неэффективна(например: хранение пар имя-фамилия).
Неприменима.

<details>
<summary> Распределение хеш-функции  </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23LengthHash%23607.png?raw=true)

</details>

#### Хеш-функия №3: Сумма элементов значения.
```clike=
Hash GetHash(const char *value)
{
    Hash hash = 0;
    size_t size = strlen(value);
    for (size_t i = 0; i < size)
        hash += value[i];
    return hash;
}
```
Хеш-функия возвращает сумму элементов полученного значения. Распределение данной реализации будет зависеть от диапазона значений элемента значения и средней длины значений.
Имеет лучшее распределение, чем все предыдущие реализации, но качество распределения сильно зависет от набора данных.
Непреминима.

<details>
<summary> Распределение хеш-функции  </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23SummaryHash%23607.png?raw=true)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23SummaryHash%2313441.png?raw=true)

</details>

#### Хеш-функия №4: Среднее значение элемента.
```clike=
Hash GetHash(const char *value)
{
    Hash hash = 0;
    size_t size = strlen(value);
    for (size_t i = 0; i < size)
        hash += value[i];
    return hash/size;
}
```
Хеш-функия возвращает среднее значение элемента полученного значения. Распределение данной реализации пиками будет совпадать с частотностью элементов.
Распределение будет зависеть от частотности элементов значений.
Непренимима.

<details>
<summary> Распределение хеш-функции  </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23SummaryLengthHash%23607.png?raw=true)

</details>

#### Хеш-функия №5: Сумма элементов значения при циклическом сдвиге вправо.
```clike=
Hash GetHash(const char *value)
{
    Hash hash = 0;
    size_t size = strlen(value)
    for (size_t i = 0; i < size)
        hash = ROR(hash) + value[i];
    return hash;
}
```
Хеш-функия возвращает сумму элементов полученного во время циклического сдвига вправо. Данная реализация имеет хорошее распределение.
Приемлема для использования.

<details>
<summary> Распределение хеш-функции  </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23RORHash%23607.png?raw=true)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23RORHash%2313441.png?raw=true)

</details>

#### Хеш-функия №6: Сумма элементов значения при циклическом сдвиге влево.
```clike=
Hash GetHash(const char *value)
{
    Hash hash = 0;
    size_t size = strlen(value);
    for (size_t i = 0; i < size)
        hash = ROL(hash) + value[i];
    return hash;
}
```
Подобна предыдущей реализации, только циклический сдвиг происходит влево.
Приемлема для использования.

<details>
<summary> Распределение хеш-функции  </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23ROLHash%23607.png?raw=true)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23ROLHash%2313441.png?raw=true)

</details>

#### Хеш-функия №7: CRC.
```clike=
Hash GetHash(const char *value)
{
    Hash hash = 0;
    size_t size = strlen(value);
    for (size_t i = 0; i < size)
    {
        for (bit bitValue : value[i])
            hash = ROR(hash) + bitValue;
        if (NeedXor(hash))
            hash ^= POLINOM;
    }
    return hash;
}
```
Алгоритм данной хеш-функции можно описать как полиномиального деления(вместо деления - исключающее или) в столбик.
Приемлема для использования.

<details>
<summary> Распределение хеш-функции  </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23CRCHash%23607.png?raw=true)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23CRCHash%2313441.png?raw=true)

</details>

#### Хеш-функия №8: GNU.
```clike=
Hash GetHash(const char *value)
{
    Hash hash = START_VALUE;
    size_t size = strlen(value);
    for (size_t i = 0; i < size)
        hash = (hash >> 5 + hash) + value[i];
    return hash;
}
```
Алгоритм данной хеш-функции использует линейную комбинацию элементов значения с коэффициентами, полученными перемножением простых чисел.
Приемлема для использования.

<details>
<summary> Распределение хеш-функции  </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23GNUHash%23607.png?raw=true)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable%23O3%23GNUHash%2313441.png?raw=true)

</details>

#### Итоги главы

Так как только у последних четырех реализаций хорошие(малые) дисперсии, то только они и будут отраженны в гистограммах.

![alt text](https://github.com/TNVC/HashTable/blob/master/plots/HashDispertion.png?raw=true)

Как видно из гистограмм, GNU - обладает наилучшей дисперсией.

### _Глава вторая. Оптимизация работы хеш-таблицы._

В данной главе мы попробуем достигнуть большей производительности, чем нам дает опция O3. Мы будем искать лимитирующие факторы и устранять их.

Для тестирования модели была выбрана GNU реализация хеш-функции из-за наилучшего(наименьшего) показателя дисперсии.

Размер модели базы данных - 163.900 уникальных пар (строка:строка).

Размер модели хеш-таблицы - 13.441 ячеек.

Тестирование будет проходить следующим образом:
- Загрузка базы данных в хеш-таблицу
- Поиск заранее предопределённого набора данных в хеш-таблице(общее количество вызова функции поиска - 1.000.000)
- Очистка хеш-таблицы

#### Оптимизация №0: Изначальная реализация.
Замерим изначальные характеристики модели для последующего сравнения.

<details>
<summary> Результаты замеров </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/callgrind/0/imag.png?raw=true)

</details>

Из таблицы видно, что лимитирующим фактором является `__strcmp_avx2`.
Оптимизировать данную функцию можно двумя способами:
- Написать свою реализацию на языке ассемблера
- Понизить нагрузку на функцию, уменьшив количество вызовов

У первого подхода есть минус - ассемблерная реализация должна быть помечена как `inline`, в противном случае, скорее всего будет негативный прирост производительности.
Так как написать `inline` функцию на языке ассемблера не всегда легкий процесс, то этот вариант был отложен как запасной.

Значит будем рассматривать второй вариант. Проанализировав все вызовы `__strcmp_avx2`, было замечено, что большинство вызовов данной функции происходит в следствии малого размера хеш-таблицы. Для каждого поиска элемента в таблице надо вызвать от 1 до 15 раз `__strcmp_avx2`. Если увеличить размер таблицы до рекомендуемой заселенности(1-2 элемента на ячейку), то количество вызовов должно сократится.

#### Оптимизация №1: Увеличение размеров таблицы.

В данной оптимизации размер таблицы был увеличен с 13.441 до 112.111.

<details>
<summary> Результаты замеров </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/callgrind/1/imag.png?raw=true)

</details>

Отметим улучшения:

(Абсолютный прирост - прирост производительности относительно начального измерения)

(Относительный прирост - прирост производительности относительно предыдущего измерения)

- Абсолютный прирост: 1,56

Можно заметить, что теперь бутылочное горлышко - `GetHash`. Как видно, в среднем на один вызов функции приходится 90 инструкций. Можно предположить, что реализация не является достаточно эффективной. Для решения данной проблемы можно либо написать свою реализацию на языке ассемблера, либо использовать ассемблерную вставку. Так как данная функция не будет `inline`(в следствии количества мест ее вызова), при полностью ассемблерной реализации, мы не получим никаких оптимизаций компилятора, когда при ассемблерной вставке какие-то оптимизации да и останутся. Так что, было принято решение использовать ассемблерную вставку.

#### Оптимизация №2: Замена реализации хеш-функции.

<details>
<summary> Результаты замеров </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/callgrind/2/imag.png?raw=true)

</details>

Отметим улучшения:

- Абсолютный    прирост: 1,84
- Относительный прирост: 1,18

Также посчитаем коэффициент полезного прироста производительности ассемблерной оптимизации(больше - лучше):
- Абсолютный: 141,54
- Относительный:  90,77

Так как `GetHash` уже была оптимизирована, то ее пропустим. Исследуя код на языке C функции `Get`, проблемных мест не было замечено. Так как изучение ассемблерного кода - затратное занятие, и на высокоуровневом языке не было замечено проблемных мест, то данная функция будет пропущена.

Следующая функция - библиотечная `_int_malloc`, для работы с динамической памятью. Также видно, что в таблице функции работы с динамической памятью занимают весомый процент инструкций.

Текущее представление использования динамической памяти - малые разобщенные области памяти, объединенные в односвязные списки. Так как скорость работы `calloc` линейно зависит от количества вызовов(и то, что эти вызовы могут происходить и в пользовательском коде), а также `DestroyHashTable` линейно зависит от количества элементов в таблице, то можно заменить библиотечные функции работы с динамической памятью на свои. Они будут реализованы так же, как и библиотечные, но будут работать в заранее выделенной области памяти. Так выделение памяти не будет зависеть от количества вызовов `malloc/calloc/realloc` в пользовательском коде, а также очистка базы данных будет сводиться к одному вызову `free`.

Но у данного решения есть важный недостаток - заполнение буфера.

При наступлении данного события можно:
- Увеличить размер таблицы, что влечет пересчитывание адресов для каждого элемента
- Выдавать ошибку переполнения буфера

Был принят второй вариант, и добавлен дисклеймер, что максимальное количество элементов, которые можно поместить в таблицу, равно `table.size * SIZE_FACTOR`. Так как рекомендую подбирать размер таблицы, чтобы в среднем на одну ячейку приходилось 1-2 элемента, то можно взять `SIZE_FACTOR` как 2 или 3.

#### Оптимизация №3: Замена стандартных функций работы с динамической памятью.

<details>
<summary> Результаты замеров </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/callgrind/3/imag.png?raw=true)

</details>

Отметим улучшения:

- Абсолютный    прирост: 2,41
- Относительный прирост: 1,31

Заметим, что в списке не видно новых функций работы с динамической памятью. Так как каждая из них вызывалась в одном месте, то была произведена их вставка.

По причинам, озвученным в предыдущем пункте, пропустим первые две функции. В таком случае первое место занимает ранее знакомая нам функция `__strcmp_avx2`. Вспомним ранее отложенную оптимизацию - замена реализации на ассемблерную. Наилучший способ использовать конкретную ассемблерную реализацию - встраиваемые функции(так как они не отключают оптимизацию). На x86_64 есть такая функция - `_mm256_testc_si256`. Но она накладывает ограничение на длину строк ровно в 32 символа. Так как средняя длина слова мала(менее 10 символов), то при использовании таблицы для слов, ограничение длины - не проблема. Но вот предложения скорее всего уже не поместятся в 32 символа. Так как `_mm256_testc_si256` работает с типом `__m256i`, то заменим тип таблицы с `<const char *, const char *>` на `<const __m256i *, const __m256i *>`. Также данное улучшение позволит нам нормировать базу данных(все слова будут длиной 32 символа), что ускорит ее загрузку. Все строки короче будут дополнены до 32 нулями, а длинней - отсеканием.

#### Оптимизация №4: Подменна типов ключа и значения, нормирование базы данных.

<details>
<summary> Результаты замеров </summary>

![alt text](https://github.com/TNVC/HashTable/blob/master/callgrind/4/imag.png?raw=true)

</details>

Отметим улучшения:

- Абсолютный    прирост: 2,86
- Относительный прирост: 1,19

После подмены типов, можно вернуться к `GetHash`. Заметим, что центральный процессор нашей установки предоставляет инструкции для получения хешей. Одна из них - ранее нам знакомый crc32. Так как зачастую аппаратная реализация быстрей программной, то используем ее. Также можно заметить что, теперь цикл по всем символам(вплоть до 32), можно заменить на 4 инструкции(которые обрабатываю по 8 символов за раз).

Но тут встает вопрос, что использовать: ассемблерную вставку или чистую ассемблерную реализацию. Для интереса, замерим и тот, и другой варианты.

#### Оптимизация №5: Повторная замена реализации хеш-функции.

<details>
<summary> Результаты замеров </summary>

#### Asm

![alt text](https://github.com/TNVC/HashTable/blob/master/callgrind/5/imag0.png?raw=true)

#### Inline asm

![alt text](https://github.com/TNVC/HashTable/blob/master/callgrind/5/imag1.png?raw=true)

</details>

Отметим улучшения:

Для Asm:

- Абсолютный    прирост: 5,68
- Относительный прирост: 1,98

Для Inline asm:

- Абсолютный    прирост: 5,54
- Относительный прирост: 1,94

Из результатов измерений видно, что ассемблерная реализация лучше ассемблерной вставки. По данной причине будем использовать именно ее.

Также посчитаем коэффициент полезного прироста производительности ассемблерной оптимизации(больше - лучше):
- Абсолютный: 710,00
- Относительный: 242,50

Из возможных оптимизаций можно реализовать параллельную загрузку базы данных. Но создание и уничтожение потоков - ресурсоемкие операции. Обслуживание потоков потребует дополнительных инструкций. Данная оптимизация уменьшит время исполнения, но увеличит количество инструкций. Поэтому она нас не интересует.

На данном месте было принято решение остановить серию оптимизаций.

#### Итоги главы

Прирост производительности версий с разными оптимизациями:
| Хар-ка                            | Инструкций  | Коэффициент |
| --------------------------------- | ----------- | ----------- |
| Start                             | 443.896.886 | -           |
| End                               |  78.195.132 | -           |
| Start:End                         | -           |   5,54      |
| Коэф. прироста производительности | -           | 710,00      |

Из таблицы видно, что мы смогли обогнать опцию O3 в 5,54 раз. Также в последней версии используется всего 8 ассемблерных строк(неучитывая встраиваемые функции).

### _Итоги_
- У компилятора есть строгие рамки при оптимизации, за пределы которых он не выйдет
- Уход от более свободных рамок к более строгим может дать значимый прирост производительности
- Не все проблемы решаются ассемблерными оптимизациями

Но стоит заметить, что оптимизация может подразумевать разные факторы. Например, как ранее предлагалось в параллельной загрузке - скорость. И обычно минимизируя один из параметров оптимизации, мы увеличиваем другой. В данной работе после нормирования базы данных ее размер увеличился в 1,5 раза(с 7MB до 10MB). А напоминать, что память всегда дефицитный ресурс, не стоит.
