
# Вычисление производительности ПО на примере хеш таблицы
### "Введение в эмуляцию вычислительных систем, компиляторные технологии и промышленное программирование"
**Выполнил Буторин Даниил**
## Цель:
    Изучить различные реализации хеш-функций, изучить их колизию и дисперсию; иследовать различные реализации инфроструктуры хеш-таблтцы на количество исполняемых операций.
## В работе используются:
    Язык программирования C\C++; набор  компиляторов GCC; инструмент
    callgring  утилиты valgring; инструмент визуализации KCachegring.
## Экспериментальная установка:
    Ноутбук  фирмы   "Honor"  на  процессоре "AMD  Ryzen  5  5500U
    with Radeon Graphics"  с OS "GNU/Linux 22.04.1-Ubuntu x86_64".
## Теоретическая справка:
Хеш-функция(функция свертки) — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины. Возвращаемые хеш-функцией значения менее разнообразны, чем входные значения. Случай, при котором хеш-функция преобразует более чем одно значение входных данных в одинаковые ключи, называется «коллизией». Вероятность возникновения коллизий используется для оценки качества хеш-функций.
Ассоциативный массив — абстрактный тип данных, позволяющий хранить пары вида (ключ, значение). Реализация ассоциативного массива может быть представленна хеш-таблицей с разрешением колизий путем цепочек(каждая ячейка - односвязанный список).
## Ход работы:
### _Глава первая. Иследование дисперсии хеш-функций._
> Так как вычисляймая дисперсия распределения хеш-функций зависит от размеров хеш-таблицы,
> то выберем ее размеры оптимальным путем: возмьем простое число из диапозона, определяймого 10-15 элементами на ячейку(`data.size/table.size`).

Далее будет приведены разные реализации хеш-функции с их описанием и диперсией в случае хорошего распоеделения.
Все реализации имеют следующую сигнатуру.
```clike=
typedef uint32_t Hash;
Hash GetHash(const void *value, size_t size);
```
#### Хеш-функия №1: Эквивалентная константе.
```clike=
Hash GetHash(const void *value, size_t size)
{
    return CONSTANT_VALUE;
}
```
Хеш-функий возвращает константу для каждого полученного значения.
Самая легкая реализация, но функция обладает крайней неэффективностью.
Непременима.
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#ConstHash#607.png)

#### Хеш-функия №2: Длина значения.
```clike=
Hash GetHash(const void *value, size_t size)
{
    return LengthOf(value);
}
```
Хеш-функий возвращает длину полученого значения. Очевидно, для задач с похошей длиной ключей неэффективна (наприме: хранение пар имя-фамилия).
В большенстве случаев непременима.
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#LengthHash#607.png)

#### Хеш-функия №3: Сумма элементов значения.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < size/ELEMENT_SIZE)
        hash += ElementOf(value, i);
    return hash;
}
```
Хеш-функий возвращает сумму элементов полученого значения. Распределение данной реализации будет зависить от диапазона значений жлемента значения и средней длины значений.
Имеет лучшее распределение, чем все предыдущие реализации, но качество распределения сильно зависить от набора данных.
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#SummaryHash#607.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#SummaryHash#7879.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#SummaryHash#13441.png)

#### Хеш-функия №4: Среднее значение элемента.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    size_t elementsCount = size/ELEMENT_SIZE;
    for (size_t i = 0; i < elementsCount)
        hash += ElementOf(value, i);
    return hash/elementsCount;
}
```
Хеш-функий возвращает среднее значение элемента полученого значения. Распределение данной реализации пиками будет совпадать с частотностью элементов.
Распределение будет зависить от частотности элементов значений.
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#SummaryLengthHash#607.png)

#### Хеш-функия №5: Сумма элементов значения при циклическом сдвиге вправо.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < elementsCount)
        hash = ROR(hash) + ElementOf(value, i);
    return hash;
}
```
Хеш-функий возвращает сумму элементов полученого во время циклического сдвига вправо. Данная реализация имеет хорошее распределение.
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#RORHash#607.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#RORHash#7879.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#RORHash#13441.png)

#### Хеш-функия №6: Сумма элементов значения при циклическом сдвиге влево.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < elementsCount)
        hash = ROL(hash) + ElementOf(value, i);
    return hash;
}
```
Подобна предыдущей реализации, только циклический сдвиг происходит влево.
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#ROLHash#607.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#ROLHash#7879.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#ROLHash#13441.png)

#### Хеш-функия №7: CRC.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < elementsCount)
    {
        for (bit bitValue : ElementOf(value, i))
            hash = ROR(hash) + bitValue;
        if (NeedXor(hash))
            hash ^= POLINOM;
    }
    return hash;
}
```
Данная реализация уже является полноценной хеш-функцией, и была выбрана из-за поддержки на машшином уровне данного алгоритма.
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#CRCHash#607.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#CRCHash#7879.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#CRCHash#13441.png)

#### Хеш-функия №8: GNU.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = START_VALUE;
    for (size_t i = 0; i < elementsCount)
        hash = hash*31 + ElementOf(value, i);
    return hash;
}
```
Данная реализация также является полноценной хеш-функцией. Она была выбрана для конкуренции с седьмой реализацией.
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#GNUHash#607.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#GNUHash#7879.png)
![alt text](https://github.com/TNVC/HashTable/blob/master/plots/DefaultTable#O3#GNUHash#13441.png)


#### Итоги главы
| Реализация | Размер базы данных | Размер хеш-таблицы | Дисперсия |
| ---------- | ------------------ | ------------------ | --------- |
| Const      | 6507               | 607                | 69639.7   |
| Const      | 100060             | 7879               | 1270560   |
| Const      | 163900             | 13441              | 1998450   |
| Length     | 6507               | 607                | 8473.47   |
| Length     | 100060             | 7879               | 111343    |
| Length     | 163900             | 13441              | 99311     |
| Summary    | 6507               | 607                | 62.7947   |
| Summary    | 100060             | 7879               | 1345.51   |
| Summary    | 163900             | 13441              | 897.288   |
| Average    | 6507               | 607                | 6776.57   |
| Average    | 100060             | 7879               | 109008    |
| Average    | 163900             | 13441              | 65031     |
| ROR        | 6507               | 607                | 22.9693   |
| ROR        | 100060             | 7879               | 191.617   |
| ROR        | 163900             | 13441              | 84.8818   |
| ROL        | 6507               | 607                | 20.0402   |
| ROL        | 100060             | 7879               | 39.9114   |
| ROL        | 163900             | 13441              | 45.0474   |
| CRC        | 6507               | 607                | 11.1868   |
| CRC        | 100060             | 7879               | 14.1437   |
| CRC        | 163900             | 13441              | 13.2707   |
| GNU        | 6507               | 607                | 10.4323   |
| GNU        | 100060             | 7879               | 14.5338   |
| GNU        | 163900             | 13441              | 13.1441   |

Как видно из результатов экспериментов относительно хорошей дисперсией обладают последние четыре реализации. Так же надо сказать, что третья реализация обладает хорошей дисперсией в первом эксперименте из-за особеностей конкретного набора данных. Как видно в большем наборе данных дисперсия этой реализации резко ухудшается.
Можно заметить что, алгоритм 5 и 6 реализации отличаются минимально, но у них разная дисперсия. Но как можно наблюдать из улучшенной модели(Оптимизация 2) видно, что дисперсия шестой реализации в 2 раза лучше пятой.

| Реализация | Размер базы данных | Размер хеш-таблицы | Дисперсия |
| ---------- | ------------------ | ------------------ | --------- |
| ROR        | 163900             | 112111             | 11.9868  |
| ROL        | 163900             | 112111             | 4.94279  |
| CRC        | 163900             | 112111             | 1.5724   |
| GNU        | 163900             | 112111             | 1.5724   |

Но выяснение данного явления требует тчательного анализа, на который у нас нет возможности. Поэтому будем апирировать апостеорным обяснением, чем априорным.
Нам известно, что деление на степень двойки откидывает n младших разрядов(то есть информация теряется). При делении на другие числа теряется не вся информация, но большая ее часть(упрощенное предположение для простоты тезиса). Так как дисперсия ROR хуже, чем ROL, то можно предположить, что ROR стремится аккумулировать данные в младшей части значения, когда ROL, наоборот, в старшей.

### _Глава вторая. Оптимизация работы хеш-таблицы._
> Будут увеличены размеры таблицы, чтобы среднее заполнение было порядка 1-2 элементов на ячейку(`data.size/table.size`).

Для экспериментов будут взяты три последнии реализации хеш-фунции.
И будут представленны варианты с опцией O0 и O3.

Для избежания оптимизации под кокретный набор данных, мы будем тусовать выбранные данные в случайном порядке.

#### Оптимизация №0: Изначальная реализация.
Для начала замерин изначальные характеристики модели.

...

Проанализировав данные можно сделать следующие выводы.

Для версий без оптимизации:
- Для CRC хеша, лимитирующий фактор - `GetHash`
- Для остальных версий, лимитирующий фактор - `LoadDataBase`
- Скорость загрузки базы данных зависит от `TABLE INSEART`, который в свою очередь зависит от `GetHash`

Для версий с оптимизации:
- Для CRC хеша, лимитирующий фактор все еще - `GetHash`
- Для GNU хеша, лимитирующий фактор - `LoadDataBase`, который в свою очередь косвенно зависит от `GetHash`
- Для остальных версий, лимитирующие факторы как и `GetHash`, так и библиотечные функции работы с динамической памятью

Из выше сказаного следует, что для оптимизации нужно:
- Заменить реализации `GetHash` на ассемблерные
- Изменить принцип взаимодействия с динамической памятью

Данные оптимизации будут реализованны в порядке их перечисления.

#### Оптимизация №1: Замена реализаций хеш-функций на ассемблерные.
> Для CRC хеша будет использоваться машинная инструкция `crc32`

...

Из данных видно, что
Для версий без оптимизации:
- Общее количество операций уменьшелось от 47M до 880M
- Для `LoadDataBase` до сих пор лимитирующие факторы как и `GetHash`, так и библиотечные функции работы с динамической памятью
Для версий с оптимизацией:
- Для CRC хеша общее количество инструкций уменьшелось на 312M
- Для остальных реализаций значимых изменений нет

Но на данном этапе было выявлена ошибка модели. Изначально предпологалось, что все предыдущие измерения фиксировались с увеличиным размером таблицы, но оказалось, что размер не был таковым.

Следующая оптимизация будет сугубо нацелена на увеличение таблицы.

#### Оптимизация №2: Увеличение размеров таблицы.

...

Анализируя данные, видно, что общее время выподнения неоптимизированного кода уменьшелось на 18M инструкций, а оптимизированного на 15.5M.

В основном уменьшелось время выполнения `REMOVE TABLE`, но также и время `INSEART` и `LOAD TABLE`.

Далее будет проведена ранее отложенная оптимизация в изменении подхода к использованию динамической памяти.

#### Оптимизация №3: Замена стандартных функций работы с динамической памятью.

Опишен последующее изменение.

На данный момент память представляет собой много разбросанных малых кусков, соединеных принципом цепочки. Так как время выполнения `NEW` линейно зависит от количества выделенной памяти(всего во время программы), а также `REMOVE TABLE`(конкретно для списков), то данный фактор будет сильно замедлять работу при большой базе данных. Было решено использовать свои ыункции работы с динамической памятью, которые будут работать в заранее заказаном большой области памяти, которая будет определяться по размеру таблицы.
В данном случае есть важный недостаток - при заполнении буффера можно:
- Увеличить размер таблицы, что влечет пересчитывание адресов для каждого элемента
- Выдавать ошибку переполнения буффера
Был принят второй вариант, и добавлен дисклеймер, что максимальное количество элементов, которые можно поместить в таблицу равны `table.size * SIZE_FACTOR`. Так как рекомендую подбирать размер таблицы, чтобы в среднем на одну ячейку приходилось 1-2 элемента, то можно взять `SIZE_FACTOR` как 2 или 3.

Правда при большом размере таблицы достаточно большая часть памяти будет занята, скорей всего, без необходимости.

...

Анализируюя данные видим, что выполнение неоптимизированнаных версий уменьшелось на 49M, а оптимизированного кода 55.5M.
Из данных результатов видно, что несмотря на внесенные огренечение прирост производительности достаточно значим.

Далее мы видим, что в зависимостях `LoadDataBase` и `Put` появились `__strchr_avx2` и `__strlen_avx2`, ф также, что их покуда не затрагивали оптимизации.

Тут можно сделать следующие оптимизации:
- Заменить тип ключа на встроенный __mm256 (решает проблему `__strlen_avx2`)
- Преобразовать файл базы данных из текстового не выровняного в бинарный выровненный
- Также можно заменить тип значения на встроенный __mm256

Так как средняя длина слова в русском языке 7.2 символа, когда в английском 5.2 символа. Так что ограничение в 32 символа (если строка фиксированной длины(а она такая, так как все незначащие символы будут заполнятся нулями), то терминатора не нужно).
Насчет замены формата файла базы данных - процес преобразования проходит один раз, но ускорение будет постоянное. Также из-за этого время преобразованния можно не учитывать (считать его временем компиляции).

Стоит заметить, выравнивание значений в файле базы данных не требуется `__strchr_avx2` для поиска нульевых символов.

#### Оптимизация №4: Подменна типа ключа.

Так как база данных еще не нормированна то значащими будем считать только первые 32 симола, все остальные симолы слова буду игнорироваться.

...

#### Оптимизация №5: Нормирование базы данных.


#### Итоги главы

#### Итоги
