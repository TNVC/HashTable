
# Вычисление производительности ПО на примере хеш таблицы
### "Введение в эмуляцию вычислительных систем, компиляторные технологии и промышленное программирование"
**Выполнил Буторин Даниил**
## Цель:
    Изучить различные реализации хеш-функций, изучить их колизию и дисперсию; иследовать различные реализации инфроструктуры хеш-таблтцы на количество исполняемых операций.
## В работе используются: 
    Язык программирования C\C++; набор  компиляторов GCC; инструмент 
    callgring  утилиты valgring; инструмент визуализации KCachegring.
## Экспериментальная установка:  
    Ноутбук  фирмы   "Honor"  на  процессоре "AMD  Ryzen  5  5500U
    with Radeon Graphics"  с OS "GNU/Linux 22.04.1-Ubuntu x86_64".
## Теоретическая справка:
Хеш-функция(функция свертки) — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины. Возвращаемые хеш-функцией значения менее разнообразны, чем входные значения. Случай, при котором хеш-функция преобразует более чем одно значение входных данных в одинаковые ключи, называется «коллизией». Вероятность возникновения коллизий используется для оценки качества хеш-функций.
Ассоциативный массив — абстрактный тип данных, позволяющий хранить пары вида (ключ, значение). Реализация ассоциативного массива может быть представленна хеш-таблицей с разрешением колизий путем цепочек(каждая ячейка - односвязанный список).
## Ход работы:
### _Глава первая. Иследование дисперсии хеш-функций._
> Так как вычисляймая дисперсия распределения хеш-функций зависит от размеров хеш-таблицы,
> то выберем ее размеры оптимальным путем: возмьем простое число из диапозона, определяймого 10-15 элементами на ячейку(`data.size/table.size`).

Далее будет приведены разные реализации хеш-функции с их описанием и диперсией в случае хорошего распоеделения.
Все реализации имеют следующую сигнатуру.
```clike=
typedef uint32_t Hash;
Hash GetHash(const void *value, size_t size);
```
#### Хеш-функия №1: Эквивалентная константе.
```clike=
Hash GetHash(const void *value, size_t size)
{
    return CONSTANT_VALUE;
}
```
Хеш-функий возвращает константу для каждого полученного значения.
Самая легкая реализация, но функция обладает крайней неэффективностью.
Непременима.
![](https://i.imgur.com/jSML2Nc.png)

#### Хеш-функия №2: Длина значения.
```clike=
Hash GetHash(const void *value, size_t size)
{
    return LengthOf(value);
}
```
Хеш-функий возвращает длину полученого значения. Очевидно, для задач с похошей длиной ключей неэффективна (наприме: хранение пар имя-фамилия).
В большенстве случаев непременима.
![](https://i.imgur.com/uVVG3kw.png)

#### Хеш-функия №3: Сумма элементов значения.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < size/ELEMENT_SIZE)
        hash += ElementOf(value, i);
    return hash;
}
```
Хеш-функий возвращает сумму элементов полученого значения. Распределение данной реализации будет зависить от диапазона значений жлемента значения и средней длины значений.
Имеет лучшее распределение, чем все предыдущие реализации, но качество распределения сильно зависить от набора данных.
![](https://i.imgur.com/zyb6NCt.png)
![](https://i.imgur.com/IUOGWnI.png)
![](https://i.imgur.com/TW8qoai.png)


#### Хеш-функия №4: Среднее значение элемента.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    size_t elementsCount = size/ELEMENT_SIZE;
    for (size_t i = 0; i < elementsCount)
        hash += ElementOf(value, i);
    return hash/elementsCount;
}
```
Хеш-функий возвращает среднее значение элемента полученого значения. Распределение данной реализации пиками будет совпадать с частотностью элементов.
Распределение будет зависить от частотности элементов значений.
![](https://i.imgur.com/VObPGBZ.png)

#### Хеш-функия №5: Сумма элементов значения при циклическом сдвиге вправо.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < elementsCount)
        hash = ROR(hash) + ElementOf(value, i);
    return hash;
}
```
Хеш-функий возвращает сумму элементов полученого во время циклического сдвига вправо. Данная реализация имеет хорошее распределение.
![](https://i.imgur.com/8TNPwae.png)
![](https://i.imgur.com/3stQpZa.png)
![](https://i.imgur.com/2lzlhcD.png)

#### Хеш-функия №6: Сумма элементов значения при циклическом сдвиге влево.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < elementsCount)
        hash = ROL(hash) + ElementOf(value, i);
    return hash;
}
```
Подобна предыдущей реализации, только циклический сдвиг происходит влево.
![](https://i.imgur.com/XIXbpej.png)
![](https://i.imgur.com/cj6RR80.png)
![](https://i.imgur.com/Z2tW58m.png)

#### Хеш-функия №7: CRC.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < elementsCount)
    {
        for (bit bitValue : ElementOf(value, i))
            hash = ROR(hash) + bitValue;
        if (NeedXor(hash))
            hash ^= POLINOM;
    }
    return hash;
}
```
Данная реализация уже является полноценной хеш-функцией, и была выбрана из-за поддержки на машшином уровне данного алгоритма.
![](https://i.imgur.com/IZXwlIs.png)
![](https://i.imgur.com/WcmBFcU.png)
![](https://i.imgur.com/ahP151F.png)

#### Итоги главы
| Реализация | Размер базы данных | Размер хеш-таблицы | Дисперсия |
| ---------- | ------------------ | ------------------ | --------- |
| Const      | 6507               | 607                | 69639.7   |
| Const      | 100060             | 7879               | 151257    |
| Const      | 163900             | 13441              | 80172.4   |
| Length     | 6507               | 607                | 8473.47   |
| Length     | 100060             | 7879               | 111343    |
| Length     | 163900             | 13441              | 99311     |
| Summary    | 6507               | 607                | 62.7947   |
| Summary    | 100060             | 7879               | 1345.51   |
| Summary    | 163900             | 13441              | 897.288   |
| Average    | 6507               | 607                | 6776.57   |
| Average    | 100060             | 7879               | 109008    |
| Average    | 163900             | 13441              | 65031     |
| ROR        | 6507               | 607                | 22.9693   |
| ROR        | 100060             | 7879               | 191.61    |
| ROR        | 163900             | 13441              | 44.8959   |
| ROL        | 6507               | 607                | 20.0402   |
| ROL        | 100060             | 7879               | 39.9114   |
| ROL        | 163900             | 13441              | 84.8818   |
| CRC        | 6507               | 607                | 11.1868   |
| CRC        | 100060             | 7879               | 14.1437   |
| CRC        | 163900             | 13441              | 13.2707   |

Как видно из результатов экспериментов относительно хорошей дисперсией обладают последние три реализации. Так же надо сказать, что третья реализация обладает хорошей дисперсией в пелом эксперименте из-за особеностей конкретного набора данных. Как видно в большем наборе данных дисперсия этой реализации резко ухудшается.
Можно заметить что, алгоритм 5 и 6 реализации отличаются минимально, но у них разная дисперсия. Но как можно наблюдать из улучшенной модели видно, что дисперсия шестой реализации в 2 раза лучше пятой.

| Реализация | Размер базы данных | Размер хеш-таблицы | Дисперсия |
| ---------- | ------------------ | ------------------ | --------- |
| ROR        | 163900             | 112111             | 0.268728  |
| ROL        | 163900             | 112111             | 0.135966  |
| CRC        | 163900             | 112111             | 0.0589534 |

Но выяснение данного явления требует тчательного анализа, на который у нас нет  возможности. Поэтому будем опирировать апостеорным обяснением, чем априорным.
Нам известно, что деление на степень двойки откидывает n младших разрядов(то есть информация теряется). При делении на другие числа теряется не вся информация, но большая ее часть(упрощенное предположение для простоты тезиса). Так как дисперсия ROR хуже, чем ROL, то можно предположить, что ROR стремится аккумулировать данные в младшей части значения, когда ROL, наоборот, в старшей.

### _Глава вторая. Оптимизация работы хеш-таблицы._
> Будет увеличены размеры таблицы, чтобы среднее заполнение было порядка 1-2 элементов на ячейку(`data.size/table.size`).

Для экспериментов будут взяты три последнии реализации хеш-фунции.
И будут представленны варианты с опцией O0 и O3.

Для избежания оптимизации под кокретный набор данных, мы будем тусовать выбранные данные в случайном порядке.

#### Оптимизация №0: Изначальная реализация.
Для начала замерин изначальные характеристики модели.

...

Как видно, при отсутсвии оптимизации лимитирующим фактором является реализации хеш-функций, но у CRC хеша это бутылочное горлышко проявляется сильней всего.

При оптимизации лишь у CRC хеша реализация - лимитирующий фактор. У других реализаций лимитирующий фактор - это инструкции INSEART и DELETE TABLE.

Решение для версий без оптимизации и для CRC с оптимизацией - реализовать их самомтоятельно на языке ассемблера. Также для CRC можно использовать встраиваемые функции.

После анализа INSEART и DELETE TABLE для остальных версий было сделано предположение, что в них лимитирующий фактор - функции работы с динамической памятью.

Текущее представление ячейки таблицы - односвязанный список(no cache frendly).
Его можно заменить на массив или же вместо библиотечных функций использовать своих, работающие с заранее заказаным буффером.

Для начало было принято решение выполнить рекоминдацию по среднему количеству элементов на ячейку: 1-2.

#### Оптимизация №1: Увеличение размеров таблицы.

Как видно увеличение размеров повлияло не сильно. Без оптимизации: количество команд на INSEART уменьшелось на (10 +- 2)M инструкций. C оптимизации: количество команд на INSEART уменьшелось на (5 +- 2)M инструкций.

Далее можно заменить реализацию на написаную в языке ассемблера.

#### Оптимизация №2: Замена реализации хеш-функций на ассемблерные.

Как видно реализации без оптимизации и CRC с оптимизацией имею значительное улучшение. В случае с другими реализациями улучшение либо минимально (1M +- 300K) инструкций или же, в принципе, отрицательный рост производительности (-4M +- 500K) инструкций.

Далее можно устранить один из лимитирующих факторов - обращение к библиотечным функциям работы с динамической памятью. Для начало будет выбрана реализация с заменной односвязанных списков на массивы.

#### Оптимизация №3: Замена односвязного списка на массив.

Можно заметить, что во всех случаях удаление таблицы уменьшилось на (11 +- 3)M инструкций, когда в случае с вставкой лишь от 1M до 5M инструкций, кроме оптимизированных версий ROL и ROR, где улучшение всставки изменилось на (10 +- 2)M инструкций.

Так же можно попробовать другой вариант оптимизации работы с динамической памятью - замена библиотечных функций на свою, которая работает с собственным буффером.

#### Оптимизация №4: Замена библиотечных функций работы с динамической памятью на свои.


#### Оптимизация №5: .
#### Итоги главы

#### Итоги
