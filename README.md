
# Вычисление производительности ПО на примере хеш таблицы
### "Введение в эмуляцию вычислительных систем, компиляторные технологии и промышленное программирование"
**Выполнил Буторин Даниил**
## Цель:
    Изучить различные реализации хеш-функций, изучить их колизию и дисперсию; иследовать различные реализации инфроструктуры хеш-таблтцы на количество исполняемых операций.
## В работе используются:
    Язык программирования C\C++; набор  компиляторов GCC; инструмент
    callgring  утилиты valgring; инструмент визуализации KCachegring.
## Экспериментальная установка:
    Ноутбук  фирмы   "Honor"  на  процессоре "AMD  Ryzen  5  5500U
    with Radeon Graphics"  с OS "GNU/Linux 22.04.1-Ubuntu x86_64".
## Теоретическая справка:
Хеш-функция(функция свертки) — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины. Возвращаемые хеш-функцией значения менее разнообразны, чем входные значения. Случай, при котором хеш-функция преобразует более чем одно значение входных данных в одинаковые ключи, называется «коллизией». Вероятность возникновения коллизий используется для оценки качества хеш-функций.
Ассоциативный массив — абстрактный тип данных, позволяющий хранить пары вида (ключ, значение). Реализация ассоциативного массива может быть представленна хеш-таблицей с разрешением колизий путем цепочек(каждая ячейка - односвязанный список).
## Ход работы:
### _Глава первая. Иследование дисперсии хеш-функций._
> Так как вычисляймая дисперсия распределения хеш-функций зависит от размеров хеш-таблицы,
> то выберем ее размеры оптимальным путем: возмьем простое число из диапозона, определяймого 10-15 элементами на ячейку(`data.size/table.size`).

Далее будет приведены разные реализации хеш-функции с их описанием и диперсией в случае хорошего распоеделения.
Все реализации имеют следующую сигнатуру.
```clike=
typedef uint32_t Hash;
Hash GetHash(const void *value, size_t size);
```
#### Хеш-функия №1: Эквивалентная константе.
```clike=
Hash GetHash(const void *value, size_t size)
{
    return CONSTANT_VALUE;
}
```
Хеш-функий возвращает константу для каждого полученного значения.
Самая легкая реализация, но функция обладает крайней неэффективностью.
Непременима.
![](https://i.imgur.com/jSML2Nc.png)
[![](path in repo)](url)
#### Хеш-функия №2: Длина значения.
```clike=
Hash GetHash(const void *value, size_t size)
{
    return LengthOf(value);
}
```
Хеш-функий возвращает длину полученого значения. Очевидно, для задач с похошей длиной ключей неэффективна (наприме: хранение пар имя-фамилия).
В большенстве случаев непременима.
![](https://i.imgur.com/uVVG3kw.png)

#### Хеш-функия №3: Сумма элементов значения.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < size/ELEMENT_SIZE)
        hash += ElementOf(value, i);
    return hash;
}
```
Хеш-функий возвращает сумму элементов полученого значения. Распределение данной реализации будет зависить от диапазона значений жлемента значения и средней длины значений.
Имеет лучшее распределение, чем все предыдущие реализации, но качество распределения сильно зависить от набора данных.
![](https://i.imgur.com/zyb6NCt.png)
![](https://i.imgur.com/IUOGWnI.png)
![](https://i.imgur.com/TW8qoai.png)


#### Хеш-функия №4: Среднее значение элемента.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    size_t elementsCount = size/ELEMENT_SIZE;
    for (size_t i = 0; i < elementsCount)
        hash += ElementOf(value, i);
    return hash/elementsCount;
}
```
Хеш-функий возвращает среднее значение элемента полученого значения. Распределение данной реализации пиками будет совпадать с частотностью элементов.
Распределение будет зависить от частотности элементов значений.
![](https://i.imgur.com/VObPGBZ.png)

#### Хеш-функия №5: Сумма элементов значения при циклическом сдвиге вправо.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < elementsCount)
        hash = ROR(hash) + ElementOf(value, i);
    return hash;
}
```
Хеш-функий возвращает сумму элементов полученого во время циклического сдвига вправо. Данная реализация имеет хорошее распределение.
![](https://i.imgur.com/8TNPwae.png)
![](https://i.imgur.com/3stQpZa.png)
![](https://i.imgur.com/2lzlhcD.png)

#### Хеш-функия №6: Сумма элементов значения при циклическом сдвиге влево.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < elementsCount)
        hash = ROL(hash) + ElementOf(value, i);
    return hash;
}
```
Подобна предыдущей реализации, только циклический сдвиг происходит влево.
![](https://i.imgur.com/XIXbpej.png)
![](https://i.imgur.com/cj6RR80.png)
![](https://i.imgur.com/Z2tW58m.png)

#### Хеш-функия №7: CRC.
```clike=
Hash GetHash(const void *value, size_t size)
{
    Hash hash = 0;
    for (size_t i = 0; i < elementsCount)
    {
        for (bit bitValue : ElementOf(value, i))
            hash = ROR(hash) + bitValue;
        if (NeedXor(hash))
            hash ^= POLINOM;
    }
    return hash;
}
```
Данная реализация уже является полноценной хеш-функцией, и была выбрана из-за поддержки на машшином уровне данного алгоритма.
![](https://i.imgur.com/IZXwlIs.png)
![](https://i.imgur.com/WcmBFcU.png)
![](https://i.imgur.com/ahP151F.png)

#### Итоги главы
| Реализация | Размер базы данных | Размер хеш-таблицы | Дисперсия |
| ---------- | ------------------ | ------------------ | --------- |
| Const      | 6507               | 607                | 69639.7   |
| Const      | 100060             | 7879               | 151257    |
| Const      | 163900             | 13441              | 80172.4   |
| Length     | 6507               | 607                | 8473.47   |
| Length     | 100060             | 7879               | 111343    |
| Length     | 163900             | 13441              | 99311     |
| Summary    | 6507               | 607                | 62.7947   |
| Summary    | 100060             | 7879               | 1345.51   |
| Summary    | 163900             | 13441              | 897.288   |
| Average    | 6507               | 607                | 6776.57   |
| Average    | 100060             | 7879               | 109008    |
| Average    | 163900             | 13441              | 65031     |
| ROR        | 6507               | 607                | 22.9693   |
| ROR        | 100060             | 7879               | 191.61    |
| ROR        | 163900             | 13441              | 44.8959   |
| ROL        | 6507               | 607                | 20.0402   |
| ROL        | 100060             | 7879               | 39.9114   |
| ROL        | 163900             | 13441              | 84.8818   |
| CRC        | 6507               | 607                | 11.1868   |
| CRC        | 100060             | 7879               | 14.1437   |
| CRC        | 163900             | 13441              | 13.2707   |

Как видно из результатов экспериментов относительно хорошей дисперсией обладают последние три реализации. Так же надо сказать, что третья реализация обладает хорошей дисперсией в пелом эксперименте из-за особеностей конкретного набора данных. Как видно в большем наборе данных дисперсия этой реализации резко ухудшается.
Можно заметить что, алгоритм 5 и 6 реализации отличаются минимально, но у них разная дисперсия. Можно предположить, что данные результаты были получены из-за специфики набора данных, но так как у нас нет реалистичной модели данных, то будем придерживатся позиции, что данные алгоритмы равноэффективны.

### _Глава вторая. Оптимизация работы хеш-таблицы._
> Будет увеличены размеры таблицы, чтобы среднее заполнение было порядка 1-2 элементов на ячейку(`data.size/table.size`).

Для экспериментов будут взяты три последнии реализации хеш-фунции.

Для избежания оптимизации под кокретный набор данных, мы будем тусовать выбранные данные в случайном порядке.



#### Итоги главы

#### Итоги
